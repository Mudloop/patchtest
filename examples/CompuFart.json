{
	"name": "CompuFart",
	"manifest": "CompuFartSynth.cmajorpatch",
	"files": [
		{
			"name": "Utils.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\n// Licensed under the MIT License https://github.com/alexmfink/compufart\n\nnamespace Audolon::Utils\n{\n    float ClipValue(float inValue, float minValue, float maxValue)\n    {\n        return max(min(inValue, maxValue), minValue);\n    }\n\n    int ClipValue(int inValue, int minValue, int maxValue)\n    {\n        return max(min(inValue, maxValue), minValue);\n    }\n}\n",
			"id": "ZWB1egQItswXhnI2",
			"mime": null
		},
		{
			"name": "LICENSE",
			"type": "file",
			"binary": null,
			"content": "MIT License\n\nCopyright (c) 2023 Alex M. Fink\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
			"id": "MZyN6tskl8aAdREy",
			"mime": null
		},
		{
			"name": "CompuFartSynth.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\n// Licensed under the MIT License https://github.com/alexmfink/compufart\n\nnamespace Audolon::CompuFart {\n\n    graph CompuFartSynth [[main]]\n    {\n        input event std::midi::Message in_midi;\n        output stream float out_audio;\n\n        input event\n        {\n\n            float in_pinch [[ name: \"Pinch\", min: 0.0f, max: 1.0f, init: 0.5f, step: 0.001f, automatable: true]];\n            float in_cheek [[ name: \"Cheek\", min: 0.0f, max: 1.0f, init: 0.5f, step: 0.001f, automatable: true]];\n            float in_strain [[ name: \"Strain\", min: 0.0f, max: 1.0f, init: 0.7f, step: 0.001f, automatable: true]];\n            float in_strainIntensity [[ name: \"Strain Intensity\", min: 0.0f, max: 1.0f, init: 0.5f, step: 0.001f, automatable: true]];\n\n            float in_pressureEnvAttackTime [[ name: \"Pressure Attack\", min: 0.0f, max: 1.0f, init: 0.005f, step: 0.001f, automatable: true]];\n            float in_pressureEnvDecayTime [[ name: \"Pressure Decay\", min: 0.0f, max: 5.0f, init: 0.020f, step: 0.001f, automatable: true]];\n            float in_pressureEnvSustainLevel [[ name: \"Pressure Sustain\", min: 0.0f, max: 1.0f, init: 0.8f, step: 0.001f, automatable: true]];\n            float in_pressureEnvReleaseTime [[ name: \"Pressure Release\", min: 0.0f, max: 5.0f, init: 0.85f, step: 0.001f, automatable: true]];\n\n            float in_pitchEnvAmount [[ name: \"Pitch Env Amount\", min: -3.0f, max: 3.0f, init: 2.0f, step: 0.001f, automatable: true]];\n            float in_pitchEnvAttackTime [[ name: \"Pitch Attack\", min: 0.0f, max: 1.0f, init: 0.005f, step: 0.001f, automatable: true]];\n            float in_pitchEnvDecayTime [[ name: \"Pitch Decay\", min: 0.0f, max: 5.0f, init: 0.3f, step: 0.001f, automatable: true]];\n            float in_pitchEnvSustainLevel [[ name: \"Pitch Sustain\", min: 0.0f, max: 1.0f, init: 0.0f, step: 0.001f, automatable: true]];\n            float in_pitchEnvReleaseTime [[ name: \"Pitch Release\", min: 0.0f, max: 5.0f, init: 0.25f, step: 0.001f, automatable: true]];\n\n            int in_reverbMode [[ name: \"Reverb\", min: 0, max: 2, init:  1, text: \"None|Toilet Bowl|Church Pew\", automatable: true ]];\n\n            float in_pitchGlideTime [[ name: \"Pitch Glide\", min: 0.0f, max: 1.0f, init: 0.1f, step: 0.001f, automatable: true]];\n            float in_pitchBendRangeSemitones [[ name: \"Pitch Bend Range\", min: 0.0f, max: 48.0f, init: 48.0f, step: 0.001f, automatable: true]];\n            bool in_modWheelOn [[ name: \"Mod Wheel\", boolean, init: false, automatable: true]];\n        }\n\n        static_assert(Audolon::Reverb::NumRepootModes == 3, \"Patch parameters assume 3 reverb modes\");\n\n        event in_reverbMode(int mode)\n        {\n            reverb.in_mode <- Audolon::Reverb::GetRePootModeForInt(mode);\n        }\n\n        node\n        {\n            singleCompufartVoice = Audolon::CompuFart::CompuFartSynthVoice;\n            reverb = Audolon::Reverb::RePoot;\n        }\n\n        connection\n        {\n            in_midi -> std::midi::MPEConverter -> singleCompufartVoice.in_midiEvent;\n\n            in_pressureEnvAttackTime -> singleCompufartVoice.in_pressureEnvAttackTime;\n            in_pressureEnvDecayTime -> singleCompufartVoice.in_pressureEnvDecayTime;\n            in_pressureEnvSustainLevel -> singleCompufartVoice.in_pressureEnvSustainLevel;\n            in_pressureEnvReleaseTime -> singleCompufartVoice.in_pressureEnvReleaseTime;\n\n            in_pitchGlideTime -> singleCompufartVoice.in_pitchGlideTime;\n            in_pitchEnvAmount -> singleCompufartVoice.in_pitchEnvAmount;\n            in_pitchEnvAttackTime -> singleCompufartVoice.in_pitchEnvAttackTime;\n            in_pitchEnvDecayTime -> singleCompufartVoice.in_pitchEnvDecayTime;\n            in_pitchEnvSustainLevel -> singleCompufartVoice.in_pitchEnvSustainLevel;\n            in_pitchEnvReleaseTime -> singleCompufartVoice.in_pitchEnvReleaseTime;\n\n            in_pitchBendRangeSemitones -> singleCompufartVoice.in_pitchBendRangeSemitones;\n            in_modWheelOn ->singleCompufartVoice.in_modWheelOn;\n\n            in_pinch -> singleCompufartVoice.in_pinch;\n            in_cheek -> singleCompufartVoice.in_cheek;\n\n            in_strain -> singleCompufartVoice.in_strain;\n            in_strainIntensity -> singleCompufartVoice.in_strainIntensity;\n\n            singleCompufartVoice.out_audio -> reverb.in_audio;\n            reverb.out_audio -> out_audio;\n        }\n\n    }\n\n    graph CompuFartSynthVoice\n    {\n        input event (std::notes::NoteOn,\n                     std::notes::NoteOff,\n                     std::notes::PitchBend,\n                     std::notes::Slide,\n                     std::notes::Pressure,\n                     std::notes::Control)    in_midiEvent;\n\n        input event\n        {\n            float in_pinch;\n            float in_cheek;\n\n            float in_strain;\n            float in_strainIntensity;\n\n            float in_pressureEnvAttackTime;\n            float in_pressureEnvDecayTime;\n            float in_pressureEnvSustainLevel;\n            float in_pressureEnvReleaseTime;\n\n            float in_pitchGlideTime;\n            float in_pitchEnvAmount;\n            float in_pitchEnvAttackTime;\n            float in_pitchEnvDecayTime;\n            float in_pitchEnvSustainLevel;\n            float in_pitchEnvReleaseTime;\n\n            float in_pitchBendRangeSemitones;\n\n            bool in_modWheelOn;\n        }\n\n        output stream float out_audio;\n\n        node\n        {\n            midi2butt = MIDI2MonoButt;\n            buttInputInterface = TerranceInputInterface;\n            buttModel = Terrance;\n            buttOutputInterface = TerranceOutputInterface;\n        }\n\n        connection\n        {\n            in_midiEvent -> midi2butt.in_midiEvent;\n\n            in_pressureEnvAttackTime -> midi2butt.in_pressureEnvAttackTime;\n            in_pressureEnvDecayTime -> midi2butt.in_pressureEnvDecayTime;\n            in_pressureEnvSustainLevel -> midi2butt.in_pressureEnvSustainLevel;\n            in_pressureEnvReleaseTime -> midi2butt.in_pressureEnvReleaseTime;\n\n            in_pitchGlideTime -> midi2butt.in_pitchGlideTime;\n            in_pitchEnvAmount -> midi2butt.in_pitchEnvAmount;\n            in_pitchEnvAttackTime -> midi2butt.in_pitchEnvAttackTime;\n            in_pitchEnvDecayTime -> midi2butt.in_pitchEnvDecayTime;\n            in_pitchEnvSustainLevel -> midi2butt.in_pitchEnvSustainLevel;\n            in_pitchEnvReleaseTime -> midi2butt.in_pitchEnvReleaseTime;\n\n            in_pitchBendRangeSemitones -> midi2butt.in_pitchBendRangeSemitones;\n            in_modWheelOn -> midi2butt.in_modWheelOn;\n\n            midi2butt.out_frequencyHz -> buttInputInterface.in_frequencyHz;\n            midi2butt.out_controlPressure -> buttInputInterface.in_controlPressure;\n            midi2butt.out_panic -> buttInputInterface.in_panic;\n            midi2butt.out_panic -> buttModel.in_panic;\n            midi2butt.out_panic -> buttOutputInterface.in_panic;\n            in_pinch -> buttInputInterface.in_pinch;\n            in_cheek -> buttInputInterface.in_cheek;\n\n            in_strain -> buttInputInterface.in_strain;\n            in_strainIntensity -> buttInputInterface.in_strainIntensity;\n\n            buttInputInterface.out_frequencyHz -> buttModel.in_frequencyHz;\n            buttInputInterface.out_pressure -> buttModel.in_pressure;\n            // buttInputInterface.out_panic -> buttModel.in_panic;\n\n            buttInputInterface.out_kc -> buttModel.in_kc;\n            buttInputInterface.out_xLowerLimit -> buttModel.in_xLowerLimit;\n            buttInputInterface.out_xUpperLimit -> buttModel.in_xUpperLimit;\n\n            buttModel.out_flow -> buttOutputInterface.in_flow;\n            buttOutputInterface.out_audio -> out_audio;\n        }\n    }\n\n\n    //! Interface to convert MIDI messages to standardized control inputs to a single model interface.\n    //! Works like a mono synth, using the latest NoteOn.\n    processor MIDI2MonoButt {\n        input event (std::notes::NoteOn,\n                     std::notes::NoteOff,\n                     std::notes::PitchBend,\n                     std::notes::Slide,\n                     std::notes::Pressure,\n                     std::notes::Control)    in_midiEvent;\n\n        input event {\n            float in_pressureEnvAttackTime;\n            float in_pressureEnvDecayTime;\n            float in_pressureEnvSustainLevel;\n            float in_pressureEnvReleaseTime;\n\n            float in_pitchGlideTime;\n            float in_pitchEnvAmount;\n            float in_pitchEnvAttackTime;\n            float in_pitchEnvDecayTime;\n            float in_pitchEnvSustainLevel;\n            float in_pitchEnvReleaseTime;\n\n            float in_pitchBendRangeSemitones;\n\n            bool in_modWheelOn;\n        }\n\n        output event\n        {\n            devoid out_panic;\n        }\n\n        output stream\n        {\n            float out_controlPressure;\n            float out_frequencyHz;\n        }\n\n        const int DefaultGlide = max(1, int(0.0005 * processor.frequency)); // 0.5 msec\n        const float DefaultFrequencyHz = 100.0f;\n        const float DefaultPitchBendRangeSemitones = 12.0f;\n\n        int m_numNotes;\n\n        var m_pressureEnvelope = Envelopes::GetADSR(processor.frequency);\n        std::smoothing::SmoothedValue m_pressureVelocityLevel; //!< The latest NoteOn Velocity used to scale the pressure\n        std::smoothing::SmoothedValue m_pressureModLevel; //!< Pressure scaling from Mod Wheel\n        bool m_modWheelOn;\n        float m_pressureModWheelTarget;\n\n        var m_pitchEnvelope = Envelopes::GetADSR(processor.frequency);\n        std::smoothing::SmoothedValue m_pitchEnvAmount;\n\n        int m_pitchGlideSamples;\n\n        std::smoothing::SmoothedValue m_smoothFrequencyHz; //!< The latest NoteOn frequency. (The frequency of zero pitch envelope level)\n        std::smoothing::SmoothedValue m_smoothPitchBend;\n        float m_pitchBendRangeSemitones;\n        float m_pitchBendTargetNormalized;\n\n        void init()\n        {\n            // Note that the envelopes should already be init'ed\n            m_numNotes = 0;\n            m_pressureVelocityLevel.reset(0.0f);\n            m_modWheelOn = false;\n            m_pressureModWheelTarget = 1.0f;\n            m_pitchGlideSamples = DefaultGlide;\n            m_pitchEnvAmount.reset(0.0f);\n            m_smoothFrequencyHz.reset(DefaultFrequencyHz);\n            m_smoothPitchBend.reset(0.0f);\n            m_pitchBendRangeSemitones = DefaultPitchBendRangeSemitones;\n            m_pitchBendTargetNormalized = 0.0f;\n        }\n\n        void Panic()\n        {\n            m_numNotes = 0;\n            m_pressureVelocityLevel.reset(0.0f);\n            // amf TODO: reset envelope and hook up more panics\n        }\n\n        event in_midiEvent (std::notes::NoteOn noteOn)\n        {\n            m_smoothFrequencyHz.setTarget(std::notes::noteToFrequency(noteOn.pitch), m_pitchGlideSamples);\n            m_pressureVelocityLevel.setTarget(noteOn.velocity, DefaultGlide);\n            if (m_numNotes == 0)\n            {\n                m_pressureEnvelope.On();\n                m_pitchEnvelope.On();\n            }\n            m_numNotes++;\n        }\n\n\n        event in_midiEvent (std::notes::NoteOff noteOff)\n        {\n            if (m_numNotes <= 0)\n            {\n                return;\n            }\n\n            m_numNotes--;\n            if (m_numNotes == 0)\n            {\n                m_pressureEnvelope.Off();\n                m_pitchEnvelope.Off();\n            }\n        }\n\n        // amf TODO: Handle more MIDI msgs (pitch, mod)\n        event in_midiEvent(std::notes::PitchBend pitchBend)\n        {\n            m_pitchBendTargetNormalized = pitchBend.bendSemitones / std::midi::semitoneBendRange;\n            updatePitchBend();\n        }\n\n\n        event in_midiEvent (std::notes::Control controlMsg)\n        {\n            if (controlMsg.control == 1)\n            {\n                m_pressureModWheelTarget = controlMsg.value;\n                updateModWheel();\n            }\n            else if (controlMsg.control == 123)\n            {\n                Panic();\n                out_panic <- devoid();\n            }\n        }\n\n        event in_pressureEnvAttackTime(float time)\n        {\n            m_pressureEnvelope.SetAttackTimeSeconds(time);\n        }\n\n        event in_pressureEnvDecayTime(float time)\n        {\n            m_pressureEnvelope.SetDecayTimeSeconds(time);\n        }\n\n        event in_pressureEnvSustainLevel(float level)\n        {\n            m_pressureEnvelope.SetSustainLevel(level);\n        }\n\n        event in_pressureEnvReleaseTime(float time)\n        {\n            m_pressureEnvelope.SetReleaseTimeSeconds(time);\n        }\n\n        event in_pitchGlideTime(float time)\n        {\n            m_pitchGlideSamples = max(1, int(processor.frequency * time));\n        }\n\n        event in_pitchEnvAmount(float amount)\n        {\n            m_pitchEnvAmount.setTarget(amount, DefaultGlide);\n        }\n\n        event in_pitchEnvAttackTime(float time)\n        {\n            m_pitchEnvelope.SetAttackTimeSeconds(time);\n        }\n\n        event in_pitchEnvDecayTime(float time)\n        {\n            m_pitchEnvelope.SetDecayTimeSeconds(time);\n        }\n\n        event in_pitchEnvSustainLevel(float level)\n        {\n            m_pitchEnvelope.SetSustainLevel(level);\n        }\n\n        event in_pitchEnvReleaseTime(float time)\n        {\n            m_pitchEnvelope.SetReleaseTimeSeconds(time);\n        }\n\n        event in_pitchBendRangeSemitones(float semitones)\n        {\n            m_pitchBendRangeSemitones = semitones;\n            updatePitchBend();\n        }\n\n        event in_modWheelOn(bool wheelOn)\n        {\n            m_modWheelOn = wheelOn;\n            updateModWheel();\n        }\n\n        void updatePitchBend()\n        {\n            m_smoothPitchBend.setTarget(m_pitchBendTargetNormalized * m_pitchBendRangeSemitones, DefaultGlide);\n        }\n\n        void updateModWheel()\n        {\n            m_pressureModLevel.setTarget(m_modWheelOn ? m_pressureModWheelTarget : 1.0f, DefaultGlide);\n        }\n\n        void main()\n        {\n            loop\n            {\n                float pitchEnvInOctaves = m_pitchEnvAmount.getNext() * m_pitchEnvelope.tick();\n                float pitchBendInSemitones = m_smoothPitchBend.getNext();\n                out_frequencyHz <- m_smoothFrequencyHz.getNext() * (2.0f **(pitchEnvInOctaves + pitchBendInSemitones / 12.0f));\n                out_controlPressure <- m_pressureVelocityLevel.getNext() * m_pressureEnvelope.tick() * m_pressureModLevel.getNext();\n                advance();\n            }\n        }\n    }\n}\n",
			"id": "sjZpAJM9apgNzz6S",
			"mime": null
		},
		{
			"name": "CompuFartSynth.cmajorpatch",
			"type": "file",
			"binary": false,
			"content": "{\n    \"CmajorVersion\":    1,\n    \"ID\":               \"com.audolon.compufart\",\n    \"version\":          \"0.1.01\",\n    \"name\":             \"CompuFart\",\n    \"description\":      \"CompuFart Fart Synthesizer\",\n    \"category\":         \"generator\",\n    \"manufacturer\":     \"Audolon\",\n    \"isInstrument\":     true,\n\n    \"source\":           [ \"Audolon.cmajor\",\n                          \"CompuFart.cmajor\",\n                          \"CompuFartSynth.cmajor\",\n                          \"Delay.cmajor\",\n                          \"Envelopes.cmajor\",\n                          \"RePoot.cmajor\",\n                          \"Utils.cmajor\" ]\n}\n",
			"id": "F6uMo5iUWF53olRd",
			"mime": null
		},
		{
			"name": "CompuFart.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\n// Licensed under the MIT License https://github.com/alexmfink/compufart\n\nnamespace Audolon::CompuFart {\n    //! Interface to convert simple or normalized inputs into physically-meaningful units for the\n    //! Terrance butthole model.\n    processor TerranceInputInterface {\n        input event\n        {\n            float in_frequencyGlideTimeSeconds;\n\n            float in_pinch; //<! A timbral control [0,1]\n            float in_cheek; //<! A timbral control [0,1]\n\n            float in_strain;\n            float in_strainIntensity;\n\n            devoid in_panic;\n        }\n\n        input stream\n        {\n            float in_frequencyHz;\n            float in_controlPressure; //<! Air pressure control signal (on [0,1])\n        }\n\n        output stream\n        {\n            float out_frequencyHz;\n            float out_pressure;\n        }\n\n        output event\n        {\n            float out_kc;\n            float out_xLowerLimit;\n            float out_xUpperLimit;\n\n            // devoid out_panic;\n        }\n\n        std::random::RNG rng;\n\n        float m_pressureNoiseMagnitude;\n        float m_prevNoiseValue;\n        float m_noiseFilterCoeff;\n\n        void init()\n        {\n            rng.seed(69L + processor.id);\n            m_pressureNoiseMagnitude = 0.f;\n            m_prevNoiseValue = 0.f;\n            m_noiseFilterCoeff = 0.0f;\n        }\n\n        event in_pinch (float pinch)\n        {\n            // Arbitrarily chosen mapping to a reasonable physical range\n            pinch = pinch*(0.75f) + 0.25f;\n            pinch *= pinch;\n            pinch *= 4.2e8f; //4.0f*105.0f*1000000.0f\n            out_kc <- pinch;\n        }\n\n        event in_cheek (float cheek)\n        {\n            // Arbitrarily chosen mappings\n            float hiLimit = cheek;\n            hiLimit *= hiLimit;\n            hiLimit = 0.0012f * hiLimit + 0.0015f;\n            float loLimit = (1.0f - cheek);\n            loLimit *= loLimit;\n            loLimit = -0.0006f * loLimit;\n\n            out_xLowerLimit <- loLimit;\n            out_xUpperLimit <- hiLimit;\n\n            // amf TODO: Stop motion? Done in original?\n        }\n\n        event in_strain(float strain)\n        {\n            const float StrainScale = 0.35f;\n            m_pressureNoiseMagnitude = Utils::ClipValue(StrainScale * strain, 0.f, StrainScale);\n        }\n\n        event in_strainIntensity(float val)\n        {\n            val = Utils::ClipValue(val, 0.0f, 1.0f);\n            float cutoffFreq = val * 10000.0f + 100.f;\n            m_noiseFilterCoeff = 1.0f - (cutoffFreq * float(twoPi) / float(processor.frequency)); // approximate\n            m_noiseFilterCoeff = Utils::ClipValue(m_noiseFilterCoeff, 0.f, 0.999f);\n        }\n\n        event in_panic(devoid nothing)\n        {\n            // amf TODO:\n        }\n\n        // Note that this method changes state involving the noise generator and its filter\n        float mapPressureControl(float pressure)\n        {\n            // Map control pressure values above the breakpoint linearly from \"min\" to \"max\".\n            // Values below the breakpoint are linearly mapped from zero to the \"min\"\n            const float PressureBreakPoint = 0.05f;\n            const float MinPressure = 4800.0f;\n            const float MaxPressure = 8000.0f;\n            if (pressure < PressureBreakPoint)\n            {\n                return pressure/PressureBreakPoint * MinPressure;\n            }\n\n            // Generate filtered noise\n            float randValue = (1.0f - m_noiseFilterCoeff) * rng.getBipolar();\n            randValue += randValue + m_noiseFilterCoeff * m_prevNoiseValue;\n            m_prevNoiseValue = randValue;\n\n            return ((pressure - PressureBreakPoint) / (1.0f - PressureBreakPoint) * (MaxPressure - MinPressure) + MinPressure) * 0.95f * (1.0f + m_pressureNoiseMagnitude * randValue);\n        }\n\n        void main()\n        {\n            loop\n            {\n                out_frequencyHz <- in_frequencyHz;\n                out_pressure <- mapPressureControl(in_controlPressure);\n                advance();\n            }\n        }\n\n    }\n\n    // A physical model-based fart synthesizer. This simulates air flowing through an\n    // asshole.\n    processor Terrance {\n        input stream float in_frequencyHz; // amf TODO: Change, eventually\n        input stream float in_pressure;\n\n        input event devoid in_panic;\n\n        input event float in_kc;\n        input event float in_xLowerLimit;\n        input event float in_xUpperLimit;\n\n        output stream float out_flow;\n        output event string out_msg;\n        output event float<8> out_values;\n\n        const float samplerate = float(processor.frequency);\n        const float samplePeriod = 1.0f / samplerate;\n\n        // Mechanical Stuff        // NOTE: There are some redundancies\n        float m_mass;            // Mass (dependent on frequency)\n        float m_QOpen;        // Quality factor for open condition.  Determines r\n        float m_QClosed;        // Quality factor for closed condition.\n        float r_;            // Damping coefficient (Dependent on m, k, Q, fLip)\n        float m_rOpen;        // Damping coefficient for open condition\n        float m_rClosed;    // Damping coefficient for closed condition\n        float m_rn;        // nonlinear damper // amf TODO: unused\n        float m_k;            // Spring coefficient (Dependent on fLip)\n        float m_kp;         // nonlinear spring coefficient (for open condition)\n        float m_kc;        // nonlinear spring coefficient (for y below limit)\n        float m_w;            // Width of lip/opening (from a front view)\n        float m_l;            // Length of lip/opening (going from inside to outside)\n        float m_x0;        // x-coord. of rest position\n        float m_y0;        // y-coord. of rest position\n        float m_xJoint;    // The position of the joint\n        float m_yJoint;    //\n        float m_yUpperLim; // Upper limit of y (hard clips)\n        float m_yLowerLim; // Lower limit of y, beyond which a nonlin. spring is applied\n        float m_xLowerLim;        // Limit of x\n        float m_xUpperLim;        // Limit of x\n        bool m_open;                // Boolean indicating if the orifice is open or closed\n        float m_SLip;        // lip/orifice opening area\n        float m_SCup;        // area of \"cup\"\n        float m_xn;        // current x-coord x[n]\n        float m_yn;        // current y-coord y[n]\n        float m_xnm1;        // previous x-coord x[n-1]\n        float m_ynm1;        // previous y-coord y[n-1]\n        float m_xnm2;        // earlier x-coord x[n-2]\n        float m_ynm2;        // earlier y-coord y[n-2]\n\n        // Fluid Stuff\n        float m_ZC;        // \"Cup\" imedance\n        float m_rho;        // Air Density (units?)\n        float m_nu;        // Air Viscosity (units?)\n        float m_c;            // Speed of sound\n        float m_p0;        // Source/mouth pressure (The primary input/ctrl variable)\n        float m_p;            // outside/cup pressure (not atmospheric pressure--this is pressure due to flowing stuff, &c.)\n        float m_pLip;        // pressure acting on the mass(es). ( Mech eqn. uses a previous value for simplicity)\n        float m_Uac;        // Flow (not counting volume swept by lip).\n        float m_Uacm1;        // from previous time\n        float m_Un;        // Total flow (***OUTPUT***)\n        float m_ULip;        // flow from sweeping of lip\n\n        const float tauFloat = float32(twoPi);\n        const float piFloat = float(pi);\n\n        void main()\n        {\n            loop\n            {\n                m_mass = (1.5f/(4.0f*piFloat*piFloat*(in_frequencyHz/16.f)));\n                m_rOpen =     (sqrt(m_mass * m_k)/m_QOpen);\n                m_rClosed =     (sqrt(m_mass * m_k)/m_QClosed);\n\n                out_flow <- tick(in_pressure);\n\n                advance();\n            }\n        }\n\n        void init() {\n            // Numbers from the aether\n            float fLip_ =     100.0f;\n            m_mass =    (1.5f/(4.0f*piFloat*piFloat*fLip_));\n            m_QOpen =     3.0f;\n            m_QClosed = 0.5f;\n            m_k =         105.0f;//(1.5*fLip_);\n            m_kp =         50.0e8f;//(m_k*1000000.0);\n            m_kc =         (1.0f * 105.0f * 1.5e6f);\n            r_ =         (sqrt(m_mass * m_k)/m_QOpen);\n            m_rOpen =     (sqrt(m_mass * m_k)/m_QOpen);\n            m_rClosed =     (sqrt(m_mass * m_k)/m_QClosed);\n            m_rn =         0.0f;\n            m_w =         0.007f;\n            m_l =         0.002f;\n\n            m_x0 =         -0.001f; //amf TODO: Why not 0.0f ???\n            m_y0 =         -0.001f;\n            m_xJoint =     0.0f;\n            m_yJoint =     0.004f;\n            m_yLowerLim= -0.0004f;\n            m_yUpperLim= 0.0002f;\n            m_xLowerLim =     -0.004f;\n            m_xUpperLim =     0.004f;\n            m_open =        true;\n\n            m_rho =        1.2f;\n            m_nu =         0.0000185f;\n            m_c =        340.0f;     // not used at time of comment\n\n            // Start still\n            m_xn =         m_x0;\n            m_yn =         m_y0;\n            m_xnm1 =     m_x0;\n            m_ynm1 =     m_y0;\n            m_xnm2 =     m_x0;\n            m_ynm2 =     m_y0;\n\n\n            m_SLip =        2.0f * m_w * m_yn;\n            m_SCup =     0.0025f;\n            m_ZC =        m_rho*m_c/m_SCup;\n\n            m_p0 =         0.0f;\n            m_p =        0.0f;\n            m_pLip =        0.0f;\n\n            m_Uac =        0.0f;\n            m_Uacm1 =     0.0f;\n            m_Un =        0.0f;\n        }\n\n        void stopMotion()\n        {\n            m_open =        true;\n\n            // Start still\n            m_xn =         m_xLowerLim;//m_x0;\n            m_yn =         m_yLowerLim;//m_x0;\n            m_xnm1 =     m_xLowerLim;//m_x0;\n            m_ynm1 =     m_yLowerLim;//m_x0;\n            m_xnm2 =     m_xLowerLim;//m_x0;\n            m_ynm2 =     m_yLowerLim;//m_x0;\n\n            m_p0 =         0.0f;\n            m_p =        0.0f;\n            m_pLip =        0.0f;\n\n            m_Uac =        0.0f;\n            m_Uacm1 =     0.0f;\n            m_Un =        0.0f;\n        }\n\n\n        void Reset()\n        {\n        }\n\n        event in_panic(devoid nothing)\n        {\n            stopMotion();\n        }\n\n        event in_kc (float kc)\n        {\n            m_kc = kc;\n        }\n\n        event in_xLowerLimit (float limit)\n        {\n            m_xLowerLim = limit;\n        }\n        event in_xUpperLimit (float limit)\n        {\n            m_xUpperLim = limit;\n        }\n\n        float tick(float inPressure)\n        {\n\n            m_p0 = inPressure;\n\n            //Update past values\n            m_xnm2 = m_xnm1;\n            m_ynm2 = m_ynm1;\n            m_xnm1 = m_xn;\n            m_ynm1 = m_yn;\n\n            // Change damping based on open/close\n            if (m_open)\n            {\n                r_ = m_rOpen;\n            }\n            else\n            {\n                r_ = m_rClosed;\n            }\n\n            // Update position\n            m_xn = (2.0f * m_mass * samplerate * samplerate - r_ * samplerate - m_k) * m_xnm1;\n            m_yn = (2.0f * m_mass * samplerate * samplerate - r_ * samplerate - m_k) * m_ynm1;\n\n            m_xn += 2.0f * m_w * (m_p0 - m_p) * (-m_ynm1);\n            m_yn += 2.0f * m_w * (m_p0 - m_p) * (m_xnm1);\n\n            m_xn += (-m_mass * samplerate * samplerate + r_ * samplerate) * m_xnm2;\n            m_yn += (-m_mass * samplerate * samplerate + r_ * samplerate) * m_ynm2;\n\n            m_xn += m_k * m_x0;\n            m_yn += m_k * m_y0;\n\n            m_xn += -2.0f * m_w * (m_p0 - m_p) * (-m_yJoint);\n            m_yn += -2.0f * m_w * (m_p0 - m_p) * (m_xJoint);\n\n            // no m_xn update this step\n            m_yn += 2.0f * m_w * m_l * m_pLip;\n\n            // Nonlinear spring for open condition\n            if (m_open)\n            {\n                m_xn += -0.5f * m_kc * ((m_xnm1 - m_x0) ** 3.0f);\n                m_yn += -0.5f * m_kc * ((m_ynm1 - m_y0) ** 3.0f);\n            }\n\n            // NONLINEAR DAMPER //\n            //m_xn -= (m_rn*m_rOpen*samplerate)*pow((m_xnm1-m_xnm2),3.0);\n            //m_yn -= (m_rn*m_rOpen*samplerate)*pow((m_ynm1-m_ynm2),3.0);\n            //////////////////////\n\n            if (m_ynm1 < m_yLowerLim)\n            {\n                float displacement = (m_ynm1 - m_yLowerLim);\n                m_yn += -0.5f * m_kp * (displacement * displacement * displacement);\n            }\n\n\n            m_xn *= samplePeriod * samplePeriod / m_mass;\n            m_yn *= samplePeriod * samplePeriod / m_mass;\n\n            if (m_yn > m_yUpperLim)\n            {\n                m_yn = m_yUpperLim;\n            }\n\n\n            if (m_xn > m_xUpperLim)\n            {\n                m_xn = m_xUpperLim;\n            }\n            else if (m_xn < m_xLowerLim)\n            {\n                m_xn = m_xLowerLim;\n            }\n\n            ///////////////////////////////////////////////\n            // Fluid stuff, etc. //////////////////////////\n\n            if (m_yn > 0.0f)\n            {\n                m_open = true;\n                m_SLip = 2.0f * m_w * m_yn;\n            }\n            else\n            {\n                m_open = false;\n                m_SLip = 0.0f;\n            }\n\n            m_ULip = m_w * ((m_xn - m_xJoint) * (m_yn - m_ynm1) * samplerate - (m_yn - m_yJoint) * (m_xn - m_xnm1) * samplerate);\n\n            if (m_open)\n            {\n                m_Uacm1 = m_Uac;\n\n                // amf TODO: move all of this in the conditionals above so it's clear that Slip won't be zero\n\n                // These need to be 64-bit because the numbers are CRAZY\n                float64 aa = 0.5f * m_rho / (m_SLip * m_SLip) -  m_rho * (1.0f / (m_SLip * m_SCup) - 1.0f / (m_SCup * m_SCup));\n                float64 bb = m_rho * m_l * samplerate / m_SLip + 12.0f * m_nu * m_w * m_w * m_l / (m_SLip * m_SLip * m_SLip);\n                float64 cc = m_p - m_p0 - m_rho * m_l * m_Uacm1 * samplerate / m_SLip;\n                float64 radicalArg = (bb * bb - 4.0f * aa * cc);\n                float64 rt = radicalArg < 0.f ? 0.0f : radicalArg ** 0.5f;\n                m_Uac = (float(-bb) + float(rt)) / (2.0f * float(aa));\n\n                m_pLip = m_p0 - 0.5f * m_rho * m_Uac * m_Uac / (m_SLip * m_SLip) - m_rho * m_l * (m_Uac - m_Uacm1) * samplerate / m_SLip - 12.0f * m_nu * m_w * m_w * m_l * m_Uac / (m_SLip * m_SLip * m_SLip);\n\n            }\n            else\n            {\n                m_Uac = 0.0f;\n                m_pLip = 0.0f;\n                // m_ULip = 0; // amf TODO: ???\n\n                // m_Uacm1 shouldn't need to be updated here\n            }\n\n            float totalFlow = m_ULip + m_Uac;\n\n            m_p = m_ZC * totalFlow;\n\n            return totalFlow;\n        }\n\n    }\n\n    processor TerranceOutputInterface\n    {\n        input stream float in_flow;\n        output stream float out_audio;\n\n        input event\n        {\n            devoid in_panic;\n        }\n\n        float m_lastIn;\n        float m_lastOut;\n\n        event in_panic(devoid nothing)\n        {\n            Reset();\n        }\n\n        void init()\n        {\n           Reset();\n        }\n\n        void Reset()\n        {\n            m_lastIn = 0.0f;\n            m_lastOut = 0.0f;\n        }\n\n\n        void main() {\n            loop {\n                // The flow is small w.r.t. full-scale [-1,1], so we apply significant gain\n                float unfilteredInput =  2500.0f * in_flow;\n                // Apply a DC-blocking filter\n                m_lastOut = 0.99f * m_lastOut + 0.995f * unfilteredInput - 0.995f * m_lastIn;\n                m_lastIn = unfilteredInput;\n                out_audio <- m_lastOut;\n                advance();\n            }\n        }\n    }\n}\n// }\n",
			"id": "X5xWoSqgnJU6ELcW",
			"mime": null
		},
		{
			"name": "README.md",
			"type": "file",
			"binary": false,
			"content": "## CompuFart\n\nThanks to [Alex Fink](https://github.com/alexmfink) for this example.\n\nCompuFart is a fart sound synthesizer that generates sound by physically modeling wind passing through an asshole. This version is programmed in Cmajor.\n\n### How to Use\n\nYou can use the provided fart synthesizer in your DAW or with a handful of tools provide by Cmajor Software. Alternatively, you can use the physical model in your own Cmajor patch!\n\n### Building your own Fart Engine\n\nThe quickest way to use the physical model is to use the `processor` named `Terrance` (the phsyical model) along with the input and output interface `processor`s, `TerranceInputInterface` and `TerranceOutputInterface`. The interface `processor`s provide a quick way to get meaningful and useful parameters and audio into and out of the model. The model should oscillate when sufficient pressure is provided to the artificial sphincter.\n\nThe provided mono synth, `CompuFartSynth` shows one possible way to construct a digital instrument with the fart engine.\n\n### Notes\n\n* The model is not currently (pitch) tuned. However, using typical pitch control inputs (keyboard, bend) should provide relative pitch control.\n* There is currently no guarantee of compatibility or consistency between different versions of the model, synth, or other patches and code. If you wish to preserve a particular sound, it is recommended that you record it and make note of the parameter values and the version and git commit SHA. Of course, you can also fork the code.\n",
			"id": "fCFFKIP5zXKzpQvh",
			"mime": "text/markdown"
		},
		{
			"name": "Audolon.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\n// Licensed under the MIT License https://github.com/alexmfink/compufart\n\nnamespace Audolon\n{\n    //! An empty token struct for use where void cannot be used (e.g., endpoint types)\n    struct devoid{}\n}\n",
			"id": "Z5oQthxt0RDmD8Ua",
			"mime": null
		},
		{
			"name": "Envelopes.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\r\n// Licensed under the MIT License https://github.com/alexmfink/compufart\r\n\r\nnamespace Audolon::Envelopes {\r\n    //! A code that must be provided to the Initialized(int) namespace that encloses structs\r\n    //! with required initialization. Such structs should generally be obtained from factory\r\n    //! functions. Using structs within other structs may prevent this, so you may then use\r\n    const int InitCodeADSR = 42069;\r\n\r\n    Initialized(InitCodeADSR)::ADSR GetADSR(float64 samplerate)\r\n    {\r\n        var adsr = Initialized(InitCodeADSR)::ADSR();\r\n        adsr.Initialize(float (samplerate));\r\n        return adsr;\r\n    }\r\n}\r\n\r\nnamespace Audolon::Envelopes::Initialized(int code)\r\n{\r\n    // This is intended to disallow usage of structs contained herein with proper initialization\r\n    static_assert(code == InitCodeADSR, \"Use the factory, or only provide the code yourself if you initialize all instances!\");\r\n\r\n    enum ADSRState\r\n    {\r\n        Off, Attack, Decay, Sustain, Release\r\n    }\r\n\r\n    //! Linear ADSR\r\n    struct ADSR\r\n    {\r\n        float m_samplerate;\r\n\r\n        ADSRState m_state;\r\n        float m_lastOut;\r\n\r\n        int m_decayTimeSamples;\r\n        int m_releaseTimeSamples;\r\n\r\n        float m_attackStep;\r\n        float m_decayStep;\r\n        float m_releaseStep;\r\n        float m_sustainLevel;\r\n\r\n        bool isInited;\r\n\r\n        void Initialize(float sampleRate)\r\n        {\r\n           this.m_samplerate = sampleRate;\r\n           this.SetAttackTimeSeconds(0.01f);\r\n           this.SetDecayTimeSeconds(0.02f);\r\n           this.SetReleaseTimeSeconds(0.5f);\r\n           this.SetSustainLevel(0.8f);\r\n           this.Reset();\r\n        }\r\n\r\n        void Reset()\r\n        {\r\n            this.m_state = ADSRState::Off;\r\n            this.m_lastOut = 0.f;\r\n        }\r\n\r\n        void On()\r\n        {\r\n            this.m_state = ADSRState::Attack;\r\n        }\r\n\r\n        void Off()\r\n        {\r\n            if (this.m_state != ADSRState::Off)\r\n            {\r\n                this.m_state = ADSRState::Release;\r\n            }\r\n        }\r\n\r\n        void SetAttackTimeSeconds(float time)\r\n        {\r\n            float timeInSamples = max(1.0f, time * this.m_samplerate);\r\n            this.m_attackStep = 1.f / timeInSamples;\r\n        }\r\n\r\n        void SetDecayTimeSeconds(float time)\r\n        {\r\n            this.m_decayTimeSamples = max(1, int(time * this.m_samplerate));\r\n            this.m_decayStep = (1.f - this.m_sustainLevel) / this.m_decayTimeSamples;\r\n        }\r\n\r\n        void SetReleaseTimeSeconds(float time)\r\n        {\r\n            this.m_releaseTimeSamples = max(1, int(time * this.m_samplerate));\r\n            this.m_releaseStep = (this.m_sustainLevel) / this.m_releaseTimeSamples;\r\n        }\r\n\r\n        void SetSustainLevel(float level) {\r\n            this.m_sustainLevel = Audolon::Utils::ClipValue(level, 0.0f, 1.0f);\r\n            this.m_decayStep = (1.f - this.m_sustainLevel) / this.m_decayTimeSamples;\r\n            this.m_releaseStep = (this.m_sustainLevel) / this.m_releaseTimeSamples;\r\n        }\r\n\r\n        float tick()\r\n        {\r\n\r\n            if (this.m_state == ADSRState::Attack)\r\n            {\r\n                this.m_lastOut += this.m_attackStep;\r\n                if (this.m_lastOut >= 1.0f)\r\n                {\r\n                    this.m_state = ADSRState::Decay;\r\n                }\r\n            }\r\n            else if (this.m_state == ADSRState::Decay)\r\n            {\r\n                this.m_lastOut -= this.m_decayStep;\r\n                if (this.m_lastOut <= this.m_sustainLevel)\r\n                {\r\n                    this.m_lastOut = this.m_sustainLevel;\r\n                    this.m_state = ADSRState::Sustain;\r\n                }\r\n            }\r\n            else if (this.m_state == ADSRState::Sustain)\r\n            {\r\n                // Nothing to do\r\n            }\r\n            else if (this.m_state == ADSRState::Release)\r\n            {\r\n                this.m_lastOut -= this.m_releaseStep;\r\n                if (this.m_lastOut <= 0.0f)\r\n                {\r\n                    this.m_state = ADSRState::Off;\r\n                }\r\n            }\r\n\r\n            this.m_lastOut = Audolon::Utils::ClipValue(this.m_lastOut, 0.0f, 1.0f);\r\n\r\n            return this.m_lastOut;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n",
			"id": "mcFy3ZY1gNqmwsUw",
			"mime": null
		},
		{
			"name": "Delay.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\n// Licensed under the MIT License https://github.com/alexmfink/compufart\n\nnamespace Audolon::Delay (using FrameType, int MaxDelay)\n{\n    //! This is a simple delay line that zeros the buffer on delay changes\n    struct DelayLine\n    {\n        // Note: All are init'ed to zero\n        FrameType[MaxDelay] m_buffer;\n        int m_delay;\n        wrap<MaxDelay> m_tapIndex;\n\n        FrameType GetNextOut()\n        {\n            return this.m_buffer[this.m_tapIndex];\n        }\n\n        FrameType Tick(FrameType inputSample)\n        {\n            FrameType outputSample = this.m_buffer[this.m_tapIndex];\n            this.m_buffer[this.m_tapIndex] = inputSample;\n            ++this.m_tapIndex;\n            if (this.m_tapIndex >= this.m_delay)\n            {\n                this.m_tapIndex -= this.m_delay;\n            }\n            return outputSample;\n        }\n\n        void Reset()\n        {\n            for (wrap<MaxDelay> index)\n            {\n                this.m_buffer[index] = 0.0;\n            }\n            this.m_tapIndex = 0;\n        }\n\n        void SetDelayLength(int delayLength)\n        {\n            this.m_delay = Audolon::Utils::ClipValue(delayLength, 1, MaxDelay);\n            this.Reset();\n        }\n\n\n    }\n}\n",
			"id": "lNM5OcZhqlixjxXf",
			"mime": null
		},
		{
			"name": "RePoot.cmajor",
			"type": "file",
			"binary": false,
			"content": "// Copyright (c) 2023 Alex M. Fink. All rights reserved.\n// Licensed under the MIT License https://github.com/alexmfink/compufart\n\nnamespace Audolon::Reverb\n{\n    const float StableGainLimit = 0.9999f;\n\n    //! Limits gains for stability in feedback paths\n    float SanitizeGain(float gain)\n    {\n        return Audolon::Utils::ClipValue(gain, -StableGainLimit, StableGainLimit);\n    }\n\n    const int MaxNumRePootFIRTaps = 3;\n\n    enum RePootMode\n    {\n        // Don't forget to update conversion functions if this is changed.\n        None, ToiletBowl, ChurchPew\n    }\n    const int NumRepootModes = 3;\n\n    RePootMode GetRePootModeForInt(int modeNumber)\n    {\n        if (modeNumber == 1)\n        {\n            return RePootMode::ToiletBowl;\n        }\n        else if (modeNumber == 2)\n        {\n            return RePootMode::ChurchPew;\n        }\n        // case 0 and to appease the compiler\n        return RePootMode::None;\n    }\n\n    //! Note that delay values beyond the Max amount in the processor will be clipped.\n    //! Feedback gain values are also clipped for stability.\n    struct RePootSettings\n    {\n        int numFIRTaps;\n        float[MaxNumRePootFIRTaps] firDelays_sec;\n        float[MaxNumRePootFIRTaps] firCoefficients;\n        float innerDelay_sec;\n        float innerGain;\n        float outerDelay_sec;\n        float outerGain;\n        float fdbkDelay_sec;\n        float fdbkGain;\n        float fdbkCutoffFreq;\n        float outputGain;\n    }\n\n    const RePootSettings ToiletBowlSettings = (\n        3, /*numFIRTaps*/\n        (0.45351474e-3f, 0.997732426e-3f, 1.360544e-3f), /*firDelays_sec*/\n        (0.7f, 0.6f, 0.9f), /*firCoefficients*/\n        1.224490e-3f, /*innerDelay_sec*/\n        0.291047f, /*innerGain*/\n        0.2721088e-3f, /*outerDelay_sec*/\n        -0.401173f, /*outerGain*/\n        2.947846e-3f, /*fdbkDelay_sec*/\n        0.668622f, /*fdbkGain*/\n        1411.76f, /*fdbkCutoffFreq*/\n        0.55f /*outputGain*/\n    );\n\n    const RePootSettings ChurchPewSettings = (\n        2, /*numFIRTaps*/\n        (6.349206e-3f, 8.61678e-3f, 1.0e-3f), /*firDelays_sec*/\n        (0.6f, 0.5f, 0.f), /*firCoefficients*/\n        3.537415e-3f, /*innerDelay_sec*/\n        0.180921f, /*innerGain*/\n        4.399093e-3f, /*outerDelay_sec*/\n        -0.30678f, /*outerGain*/\n        20.1814059e-3f, /*fdbkDelay_sec*/\n        0.196654f, /*fdbkGain*/\n        705.882f, /*fdbkCutoffFreq*/\n        0.6f /*outputGain*/\n    );\n\n    /*\n    *\n    *      Reverberator for farts--not setup for dynamic modification (e.g., moving delay length)\n    *\n    *      Reverb model is a nested allpass with LPF'ed delayed feedback, as well as a pre-FIR echo\n    *      (sparse) filter.\n    *\n    *                                           -g_o\n    *                   +------------------------|>----------------------------+\n    *                   |                            -g_i                      |\n    *                   |                    +--------|>------------+          |\n    *                   |                    |                      |          |\n    *                   |                    |                      V          V           g_out\n    *  -->[FIR]-->(+)---+---(+)--->[Delay]---+-->(+)--->[Delay]--->(+)---+--->(+)---+---+---|>--->\n    *              ^         ^                    ^                      |          |   |\n    *              |         |                    |            g_i       |          |   |\n    *              |         |                    +------------<|--------+          |   |\n    *              |         |                           g_o                        |   |\n    *              |         +---------------------------<|-------------------------+   |\n    *              |              g_fdbk                                                |\n    *              +---------------<|---[Delay]<---[LPF]<-------------------------------+\n    *\n    */\n\n    //! This is a reverb model developed for fart processing.\n    processor RePoot\n    {\n        input stream float in_audio;\n        output stream float out_audio;\n\n        input event RePootMode in_mode;\n\n        // Delay limits, based on the max values used with the presets.\n        const float MaxFIRDelaySeconds = 10e-3f;\n        const float MaxAllpassDelaySeconds = 5e-3f;\n        const float MaxFeedbackDelaySeconds = 25e-3f;\n        const int MaxFIRDelay = int(ceil(MaxFIRDelaySeconds * float(96000.0)));\n        const int MaxAllpassDelay = int(ceil(MaxAllpassDelaySeconds * float(96000.0)));\n        const int MaxFeedbackDelay = int(ceil(MaxFeedbackDelaySeconds * float(96000.0)));\n\n        bool m_isBypassed;\n\n        RePootMode m_mode;\n\n        Delay(float, MaxAllpassDelay)::DelayLine m_innerDelay;\n        Delay(float, MaxAllpassDelay)::DelayLine m_outerDelay;\n        Delay(float, MaxFeedbackDelay)::DelayLine m_fdbkDelay;\n\n        float[MaxFIRDelay] m_firBuffer;\n        int m_numFIRTaps;\n        int[MaxNumRePootFIRTaps] m_firDelays;\n        float [MaxNumRePootFIRTaps] m_firCoefficients;\n        wrap<MaxFIRDelay> m_firWriteIndex;\n\n        float m_lastLPFOutput;\n        float m_lpfCoefficient;\n        float m_lpfNormalizingGain;\n\n        float m_innerGain;\n        float m_outerGain;\n        float m_fdbkGain;\n        float m_outputGain;\n\n        void init()\n        {\n            setMode(RePootMode::ToiletBowl);\n        }\n\n        event in_mode(RePootMode mode)\n        {\n            setMode(mode);\n        }\n\n        int delayInSecondsToLength(float inDelaySeconds)\n        {\n            return roundToInt(inDelaySeconds * float(processor.frequency));\n        }\n\n        void setLPF(float cutoffFreq)\n        {\n            // Design a one-pole LPF with the gain at DC set to 1\n            // Note that the negative of the coefficient is used later\n            m_lpfCoefficient = (cutoffFreq * float(twoPi) / float(processor.frequency)) - 1.0f; // approximate\n            m_lpfCoefficient = SanitizeGain(min(0.0f, m_lpfCoefficient));\n            m_lpfNormalizingGain = 1.0f + m_lpfCoefficient;\n        }\n\n        void setMode(RePootMode mode)\n        {\n            m_mode = mode;\n\n            if (m_mode == RePootMode::None)\n            {\n                // We will simply bypass in the processing function, so there is\n                // nothing we must do here.\n            }\n            else if (m_mode == RePootMode::ToiletBowl)\n            {\n                setParameters(ToiletBowlSettings);\n            }\n            else if (m_mode == RePootMode::ChurchPew)\n            {\n                setParameters(ChurchPewSettings);\n            }\n        }\n\n        void setParameters (RePootSettings parameters)\n        {\n            m_numFIRTaps = parameters.numFIRTaps;\n            for (wrap<MaxNumRePootFIRTaps> tapIndex)\n            {\n                m_firDelays[tapIndex] = delayInSecondsToLength(parameters.firDelays_sec[tapIndex]);\n                m_firCoefficients[tapIndex] = parameters.firCoefficients[tapIndex];\n            }\n            m_innerDelay.SetDelayLength(delayInSecondsToLength(parameters.innerDelay_sec));\n            m_innerGain = SanitizeGain(parameters.innerGain);\n            m_outerDelay.SetDelayLength(delayInSecondsToLength(parameters.outerDelay_sec));\n            m_outerGain = SanitizeGain(parameters.outerGain);\n            m_fdbkDelay.SetDelayLength(delayInSecondsToLength(parameters.fdbkDelay_sec));\n            m_fdbkGain = SanitizeGain(parameters.fdbkGain);\n            setLPF(parameters.fdbkCutoffFreq);\n            m_outputGain = parameters.outputGain;\n            Reset();\n        }\n\n        void Reset()\n        {\n            m_innerDelay.Reset();\n            m_outerDelay.Reset();\n            m_fdbkDelay.Reset();\n            m_lastLPFOutput = 0.0f;\n            for (wrap<MaxFIRDelay> bufferIndex)\n            {\n                m_firBuffer[bufferIndex] = 0.0f;\n            }\n        }\n\n        void main()\n        {\n            loop\n            {\n                // Hard bypass\n                if (m_mode == RePootMode::None)\n                {\n                    out_audio <- in_audio;\n                }\n                else\n                {\n                    float temp = in_audio;\n\n                    // FIR Filter\n                    for (wrap<MaxNumRePootFIRTaps> tapIndex)\n                    {\n                        if (tapIndex >= m_numFIRTaps)\n                        {\n                            break;\n                        }\n                        wrap<MaxFIRDelay> readIndex = wrap<MaxFIRDelay>(m_firWriteIndex + MaxFIRDelay - m_firDelays[tapIndex]);\n                        temp += m_firCoefficients[tapIndex] * m_firBuffer[readIndex];\n                    }\n                    m_firBuffer[m_firWriteIndex] = in_audio;\n                    m_firWriteIndex++; // Wraps itself!\n\n                    // Nested Allpass\n                    temp += m_fdbkGain * m_fdbkDelay.GetNextOut();\n                    float innerAllpassOutput = m_innerDelay.GetNextOut() - (m_innerGain * m_outerDelay.GetNextOut());\n                    float preGainOutValue = innerAllpassOutput - (m_outerGain * temp);\n                    temp += m_outerGain * preGainOutValue;\n                    m_innerDelay.Tick(m_outerDelay.Tick(temp) + m_innerGain * innerAllpassOutput);\n\n                    // LPF'ed Feedback\n                    m_lastLPFOutput = m_lpfNormalizingGain * preGainOutValue - m_lpfCoefficient * m_lastLPFOutput;\n                    m_fdbkDelay.Tick(m_lastLPFOutput);\n\n                    out_audio <- preGainOutValue * m_outputGain;\n                }\n                advance();\n            }\n        }\n    }\n\n}\n",
			"id": "D3LJ1xa6HQM0Wklf",
			"mime": null
		}
	]
}