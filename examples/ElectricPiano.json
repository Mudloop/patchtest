{
	"name": "ElectricPiano",
	"manifest": "ElectricPiano.cmajorpatch",
	"files": [
		{
			"name": "ElectricPiano.cmajor",
			"type": "file",
			"binary": false,
			"content": "//\n//     ,ad888ba,                              88\n//    d8\"'    \"8b\n//   d8            88,dba,,adba,   ,aPP8A.A8  88     (C)2024 Cmajor Software Ltd\n//   Y8,           88    88    88  88     88  88\n//    Y8a.   .a8P  88    88    88  88,   ,88  88     https://cmajor.dev\n//     '\"Y888Y\"'   88    88    88  '\"8bbP\"Y8  88\n//                                           ,88\n//                                        888P\"\n//\n//  This code may be used under either a GPLv3 or commercial\n//  license: see LICENSE.md for more details.\n\n\ngraph ElectricPiano  [[ main ]]\n{\n    input event std::midi::Message midiIn  [[ name: \"MIDI input\" ]];\n    input paramsProcessor.*;\n\n    output stream float<2> audioOut  [[ name: \"Audio Out\" ]];\n\n    node\n    {\n        voices = Voice[16];\n        voiceAllocator = std::voices::VoiceAllocator(16);\n        paramsProcessor = Instrument::ParamsProcessor;\n        tremolo = Tremolo;\n    }\n\n    connection\n    {\n        midiIn -> std::midi::MPEConverter -> voiceAllocator -> voices.eventsIn;\n\n        paramsProcessor.paramsOut -> voices.paramsIn, tremolo.paramsIn;\n        voices.audioOut -> tremolo.in;\n        tremolo.out -> audioOut;\n    }\n}\n\n//==============================================================================\nnamespace Instrument\n{\n    let harmonics = 32;\n\n    struct Params\n    {\n        float brightness;\n        float velocityScaling;\n        float decayRate;\n        float harmonicDecayRate;\n        float keyScaling;\n        float releaseRate;\n        float vibratoDepth;\n        float vibratoRate;\n\n        float<harmonics> getDecay (float note)\n        {\n            float baseDecayRate = (this.decayRate / 40000.0f);\n            float harmonicScaling = 1.0f - (this.harmonicDecayRate / 200000.0f);\n\n            float scalingMultiplier = (48.0f - note) / 12.0f;\n            float keyScalingFactor = scalingMultiplier * (this.keyScaling * 0.02f);\n\n            if (keyScalingFactor > 0)\n                baseDecayRate = 1.0f - (baseDecayRate / (1.0f + keyScalingFactor));\n            else\n                baseDecayRate = 1.0f - (baseDecayRate * (1.0f - keyScalingFactor));\n\n            float<harmonics> decay;\n            float scaling = 1.0f;\n\n            for (wrap<harmonics> i)\n            {\n                decay[i] = baseDecayRate * scaling;\n                scaling *= harmonicScaling;\n            }\n\n            return decay;\n        }\n\n        float<harmonics> getRelease (float note)\n        {\n            return 0.999f - (this.releaseRate / 1000.0f);\n        }\n\n        float<Instrument::harmonics> getInitialAmplitudes (float note, float  velocity)\n        {\n            let velocity100 = float<Instrument::harmonics> (0.150869f, 0.385766f, 0.215543f, 0.117811f, 0.100411f, 0.0128637f,\n                                                            0.0288844f, 0.00243388f, 0.00963092f, 0.0035634f, 0.00256945f, 0.00184799f,\n                                                            0.000399878f, 0.000660576f, 3.00995e-05f, 0.00021866f, 9.33705e-05f,\n                                                            0.000177973f, 0.0002545f, 0.000323602f, 0.000779045f, 0.000116569f,\n                                                            0.000772873f, 0.000364486f, 0.000248027f, 0.00018236f, 3.27292e-05f,\n                                                            6.64988e-05f, 0.0f, 0.0f, 0.0f, 0.0f);\n\n            let velocity0   = float<Instrument::harmonics> (0.02f, 0.05f, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                                                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n            var v = (velocity100 * velocity) + (velocity0 * (1.0f - velocity));\n\n            float brightnessScaling = -0.2f + (0.8f * (this.brightness * 0.01f));\n\n            brightnessScaling += (velocity * this.velocityScaling * 0.01f * 0.5f);\n\n            for (wrap<harmonics> i)\n                v[i] *= (1.0f + brightnessScaling * float (i));\n\n            return v;\n        }\n    }\n\n    Params createParams()\n    {\n        Params p;\n\n        p.decayRate = 10;\n        p.releaseRate = 20;\n        p.keyScaling = 50;\n        p.harmonicDecayRate = 20;\n\n        return p;\n    }\n\n    processor ParamsProcessor\n    {\n        input event float brightness            [[ name: \"Brightness\",          min: 0.0, max: 100.0, init: 30, unit: \"%\" ]];\n        input event float velocityScaling       [[ name: \"Velocity Scaling\",    min: 0.0, max: 100.0, init: 50, unit: \"%\" ]];\n        input event float decayRate             [[ name: \"Decay Rate\",          min: 0.0, max: 100.0, init: 10, unit: \"%\" ]];\n        input event float harmonicDecayRate     [[ name: \"Harmonic Decay Rate\", min: 0.0, max: 100.0, init: 30, unit: \"%\" ]];\n        input event float keyScaling            [[ name: \"Key Scaling\",         min: 0.0, max: 100.0, init: 50, unit: \"%\" ]];\n        input event float releaseRate           [[ name: \"Release Rate\",        min: 0.0, max: 100.0, init: 60, unit: \"%\" ]];\n        input event float vibratoDepth          [[ name: \"Vibrato Intensity\",   min: 0.0, max: 100.0, init: 25, unit: \"%\" ]];\n        input event float vibratoRate           [[ name: \"Vibrato Speed\",       min: 0.0, max: 100.0, init: 50, unit: \"%\" ]];\n\n        output event Instrument::Params paramsOut;\n\n        Instrument::Params params = createParams();\n\n        event brightness (float f)          { params.brightness = f;            paramsOut <- params; }\n        event velocityScaling (float f)     { params.velocityScaling = f;       paramsOut <- params; }\n        event decayRate (float f)           { params.decayRate = f;             paramsOut <- params; }\n        event harmonicDecayRate (float f)   { params.harmonicDecayRate = f;     paramsOut <- params; }\n        event keyScaling (float f)          { params.keyScaling = f;            paramsOut <- params; }\n        event releaseRate (float f)         { params.releaseRate = f;           paramsOut <- params; }\n        event vibratoDepth (float f)        { params.vibratoDepth = f;          paramsOut <- params; }\n        event vibratoRate (float f)         { params.vibratoRate = f;           paramsOut <- params; }\n    }\n}\n\n//==============================================================================\ngraph Voice\n{\n    input event Instrument::Params paramsIn;\n    input event (std::notes::NoteOn, std::notes::NoteOff) eventsIn;\n\n    output stream float audioOut;\n\n    node\n    {\n        osc = OscillatorBank (Instrument::harmonics);\n        amplitudeSource = AmplitudeSource;\n    }\n\n    connection\n    {\n        paramsIn  -> osc.paramsIn, amplitudeSource.paramsIn;\n        eventsIn  -> osc.eventsIn, amplitudeSource.eventsIn;\n\n        amplitudeSource.out -> osc.amplitudes;\n        osc.audioOut        -> audioOut;\n    }\n}\n\n//==============================================================================\nprocessor OscillatorBank (int size = 64)\n{\n    input event (std::notes::NoteOn) eventsIn;\n    input event Instrument::Params paramsIn;\n    input stream float<size> amplitudes;\n\n    output stream float audioOut;\n\n    event paramsIn (Instrument::Params p)\n    {\n        params = p;\n    }\n\n    event eventsIn (std::notes::NoteOn e)\n    {\n        notePitch = e.pitch;\n        oscillators = 1.0f;\n        setMultipliers();\n    }\n\n    Instrument::Params params;\n\n    float<Instrument::harmonics> decay, release;\n    float notePitch;\n\n    void setMultipliers()\n    {\n        let noteFrequency = std::notes::noteToFrequency (notePitch);\n        let nyquist = float (processor.frequency / 2.0);\n\n        for (wrap<size> i)\n        {\n            let harmonicFrequency = noteFrequency * (int (i) + 1);\n\n            if (harmonicFrequency < nyquist)\n            {\n                let angle = float32 (twoPi * harmonicFrequency * processor.period);\n                multiplier[i].real = cos (angle);\n                multiplier[i].imag = sin (angle);\n            }\n            else\n            {\n                multiplier[i] = 1.0f;\n            }\n        }\n    }\n\n    complex32<size> oscillators = 1.0f,\n                    multiplier = 1.0f;\n\n    void main()\n    {\n        loop\n        {\n            oscillators = oscillators * multiplier;\n\n            if const (size == 1)\n                audioOut <- oscillators.imag * amplitudes;\n            else\n                audioOut <- sum (oscillators.imag * amplitudes);\n\n            advance();\n        }\n    }\n}\n\n//==============================================================================\nprocessor AmplitudeSource\n{\n    input event (std::notes::NoteOn, std::notes::NoteOff) eventsIn;\n    input event Instrument::Params paramsIn;\n\n    output stream float<Instrument::harmonics> out;\n\n    Instrument::Params params;\n    let interpolatedSteps = 64;\n    float<Instrument::harmonics> currentValue, release, decay;\n    bool released = false;\n\n    event paramsIn (Instrument::Params p)\n    {\n        params = p;\n    }\n\n    event eventsIn (std::notes::NoteOn e)\n    {\n        release      = params.getRelease (e.pitch);\n        decay        = params.getDecay (e.pitch);\n        currentValue = params.getInitialAmplitudes (e.pitch, e.velocity);\n        released     = false;\n    }\n\n    event eventsIn (std::notes::NoteOff e)\n    {\n        released = true;\n    }\n\n    void main()\n    {\n        loop\n        {\n            let target = currentValue * (released ? release : decay);\n            let increment = (target - currentValue) / interpolatedSteps;\n\n            loop (interpolatedSteps)\n            {\n                out <- currentValue;\n                currentValue += increment;\n                advance();\n            }\n        }\n    }\n}\n\n//==============================================================================\nprocessor Tremolo\n{\n    input stream float32 in;\n    output stream float32<2> out;\n\n    input event Instrument::Params paramsIn;\n\n    float frames = 10000;\n    float depth = 0;\n    float current = 0.5f;\n\n    event paramsIn (Instrument::Params p)\n    {\n        frames = float (processor.frequency) / (1 + (p.vibratoRate / 10.0f));\n        depth = p.vibratoDepth / 200.0f;\n    }\n\n    void stepTo (float target)\n    {\n        let step = (target - current) / frames;\n\n        loop (int (frames))\n        {\n            out <- float<2> (in * current, in * (1.0f - current));\n            current += step;\n            advance();\n        }\n    }\n\n    void main()\n    {\n        loop\n        {\n            stepTo (0.5f + depth);\n            stepTo (0.5f - depth);\n        }\n    }\n}\n",
			"id": "R6aHGceplifsQ5I2",
			"mime": null
		},
		{
			"name": "README.md",
			"type": "file",
			"binary": false,
			"content": "## Additive Piano\n\nThis example patch is a model of an electric piano, implemented using additive synthesis.\n",
			"id": "5dkDAWp9FSznDVXp",
			"mime": "text/markdown"
		},
		{
			"name": "ElectricPiano.cmajorpatch",
			"type": "file",
			"binary": false,
			"content": "{\n    \"CmajorVersion\":    1,\n    \"ID\":               \"dev.cmajor.examples.electricpiano\",\n    \"version\":          \"1.0\",\n    \"name\":             \"Electric Piano\",\n    \"description\":      \"An additive model of an electric piano\",\n    \"category\":         \"generator\",\n    \"manufacturer\":     \"Cmajor Software Ltd\",\n    \"isInstrument\":     true,\n\n    \"source\":           \"ElectricPiano.cmajor\"\n}\n",
			"id": "ymjmhrMupXy5kakM",
			"mime": null
		}
	]
}