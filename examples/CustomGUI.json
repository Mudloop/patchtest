{
	"name": "CustomGUI",
	"manifest": "Freeverb_CustomGUI.cmajorpatch",
	"files": [
		{
			"name": "demo_ui",
			"type": "directory",
			"children": [
				{
					"name": "index.js",
					"type": "file",
					"binary": false,
					"content": "\n/*\n    This simple web component just manually creates a set of plain sliders for the\n    known parameters, and uses some listeners to connect them to the patch.\n*/\nclass DemoView extends HTMLElement\n{\n    constructor (patchConnection)\n    {\n        super();\n        this.patchConnection = patchConnection;\n        this.classList = \"demo-patch-element\";\n        this.innerHTML = this.getHTML();\n    }\n\n    connectedCallback()\n    {\n        this.paramListener = (event) =>\n        {\n            // Each of our sliders has the same IDs as an endpoint, so we can find\n            // the HTML element from the endpointID that has changed:\n            const slider = this.querySelector (\"#\" + event.endpointID);\n\n            if (slider)\n                slider.value = event.value;\n        };\n\n        // Attach a parameter listener that will be triggered when any param is moved\n        this.patchConnection.addAllParameterListener (this.paramListener);\n\n        for (const param of this.querySelectorAll (\".param\"))\n        {\n            // When one of our sliders is moved, this will send the new value to the patch.\n            param.oninput = () => this.patchConnection.sendEventOrValue (param.id, param.value);\n\n            // for each slider, request an initial update, to make sure it shows the right value\n            this.patchConnection.requestParameterValue (param.id);\n        }\n    }\n\n    disconnectedCallback()\n    {\n        // when our element goes offscreen, we should remove any listeners\n        // from the PatchConnection (which may be shared with other clients)\n        this.patchConnection.removeAllParameterListener (this.paramListener);\n    }\n\n    getHTML()\n    {\n        return `\n        <style>\n            .demo-patch-element {\n                background: #bcb;\n                display: block;\n                width: 100%;\n                height: 100%;\n                padding: 10px;\n                overflow: auto;\n            }\n\n            .param {\n                display: inline-block;\n                margin: 10px;\n                width: 300px;\n            }\n        </style>\n\n        <div id=\"controls\">\n          <input type=\"range\" class=\"param\" id=\"roomSize\" min=\"0\" max=\"100\">Room Size</input>\n          <input type=\"range\" class=\"param\" id=\"damping\"  min=\"0\" max=\"100\">Damping</input>\n          <input type=\"range\" class=\"param\" id=\"width\"    min=\"0\" max=\"100\">Width</input>\n          <input type=\"range\" class=\"param\" id=\"wetLevel\" min=\"0\" max=\"100\">Wet Level</input>\n          <input type=\"range\" class=\"param\" id=\"dryLevel\" min=\"0\" max=\"100\">Dry Level</input>\n        </div>`;\n    }\n}\n\nwindow.customElements.define (\"demo-patch-view\", DemoView);\n\n/* This is the function that a host (the command line patch player, or a Cmajor plugin\n   loader, or our VScode extension, etc) will call in order to create a view for your patch.\n\n   Ultimately, a DOM element must be returned to the caller for it to append to its document.\n   However, this function can be `async` if you need to perform asyncronous tasks, such as\n   fetching remote resources for use in the view, before completing.\n\n   When using libraries such as React, this is where the call to `ReactDOM.createRoot` would\n   go, rendering into a container component before returning.\n*/\nexport default function createPatchView (patchConnection)\n{\n    return new DemoView (patchConnection);\n}\n",
					"id": "DRtOLkPGoX0djLcJ",
					"mime": "text/javascript"
				}
			],
			"id": "uKc3rS4CuQDphDTG"
		},
		{
			"name": "Freeverb_CustomGUI.cmajorpatch",
			"type": "file",
			"binary": false,
			"content": "{\n    \"CmajorVersion\":    1,\n    \"ID\":               \"dev.cmajor.examples.customgui\",\n    \"version\":          \"1.0\",\n    \"name\":             \"Freeverb (with custom GUI)\",\n    \"description\":      \"A version of the Freeverb patch with a modified GUI\",\n    \"category\":         \"effect\",\n    \"manufacturer\":     \"Cmajor Software Ltd\",\n    \"isInstrument\":     false,\n\n    \"source\":           \"Freeverb_CustomGUI.cmajor\",\n\n    \"view\":             {\n                            \"src\": \"demo_ui/index.js\",\n                            \"width\": 500,\n                            \"height\": 250,\n                            \"resizable\": false\n                        }\n}\n",
			"id": "1aqMKTDdW0OLUWR5",
			"mime": null
		},
		{
			"name": "Freeverb_CustomGUI.cmajor",
			"type": "file",
			"binary": false,
			"content": "/*\n    Cmajor Freeverb Example\n    =======================\n\n    Yes folks, it's yet another implementation of that classic Freeverb algorithm\n    that we all know and love!\n\n    Big shout out to Jezar, the original author of Freeverb :)\n*/\n\ngraph Freeverb   [[ main ]]\n{\n    input stream float audioIn;\n    output stream float<2> audioOut;\n\n    input parameterScaler.roomSize  [[ name: \"Room Size\",       min: 0, max: 100, init:  80, text: \"Tiny|Small|Medium|Large|Hall\" ]];\n    input parameterScaler.damping   [[ name: \"Damping Factor\",  min: 0, max: 100, init:  50, unit: \"%\",  step: 1 ]];\n    input parameterScaler.width     [[ name: \"Width\",           min: 0, max: 100, init: 100, unit: \"%\",  step: 1 ]];\n    input parameterScaler.wetLevel  [[ name: \"Wet Level\",       min: 0, max: 100, init:  33, unit: \"%\",  step: 1 ]];\n    input parameterScaler.dryLevel  [[ name: \"Dry Level\",       min: 0, max: 100, init:  40, unit: \"%\",  step: 1 ]];\n\n    //==============================================================================\n    node parameterScaler   = ParameterScaler;\n    node wetGainSmoother   = std::smoothing::SmoothedValueStream (0.02f);\n    node dryGainSmoother   = std::smoothing::SmoothedValueStream (0.02f);\n    node widthSmoother     = std::smoothing::SmoothedValueStream (0.02f);\n    node dampingSmoother   = std::smoothing::SmoothedValueStream (0.02f);\n    node feedbackSmoother  = std::smoothing::SmoothedValueStream (0.02f);\n\n    node reverbL = MonoReverb (0);\n    node reverbR = MonoReverb (23);\n\n    node mixer = WetDryMixer;\n\n    connection\n    {\n        audioIn -> mixer.audioInDry;\n        audioIn -> reverbL.audioIn; reverbL -> mixer.audioInWetL;\n        audioIn -> reverbR.audioIn; reverbR -> mixer.audioInWetR;\n\n        parameterScaler.wetGainOut  -> wetGainSmoother  -> mixer.wetGain;\n        parameterScaler.dryGainOut  -> dryGainSmoother  -> mixer.dryGain;\n        parameterScaler.widthOut    -> widthSmoother    -> mixer.width;\n        parameterScaler.dampingOut  -> dampingSmoother  -> reverbL.damping, reverbR.damping;\n        parameterScaler.feedbackOut -> feedbackSmoother -> reverbL.feedback, reverbR.feedback;\n\n        mixer -> audioOut;\n    }\n}\n\n//==============================================================================\n// This processor intercepts incoming parameter events and rescales them to the correct range\nprocessor ParameterScaler\n{\n    input event float roomSize, damping, wetLevel, dryLevel, width;\n    output event float wetGainOut, dryGainOut, widthOut, dampingOut, feedbackOut;\n\n    let wetScaleFactor  = 1.5f;\n    let dryScaleFactor  = 2.0f;\n    let roomScaleFactor = 0.28f;\n    let roomOffset      = 0.7f;\n    let dampScaleFactor = 0.4f;\n\n    event roomSize (float newValue)    { feedbackOut <- newValue * roomScaleFactor / 100.0f + roomOffset; }\n    event damping  (float newValue)    { dampingOut  <- newValue * dampScaleFactor / 100.0f; }\n    event dryLevel (float newValue)    { dryGainOut  <- newValue * dryScaleFactor / 100.0f; }\n    event wetLevel (float newValue)    { wetGainOut  <- newValue * wetScaleFactor / 100.0f; }\n    event width    (float newValue)    { widthOut    <- newValue / 100.0f; }\n}\n\n//==============================================================================\nprocessor WetDryMixer\n{\n    output stream float<2> out;\n\n    input stream float audioInDry, audioInWetL, audioInWetR;\n    input stream float width, wetGain, dryGain;\n\n    void main()\n    {\n        loop\n        {\n            let wetGain1 = wetGain * (1.0f + width);\n            let wetGain2 = wetGain * (1.0f - width);\n\n            let wet = float<2> (audioInWetL * wetGain1 + audioInWetR * wetGain2,\n                                audioInWetR * wetGain1 + audioInWetL * wetGain2);\n\n            out <- wet + dryGain * audioInDry;\n            advance();\n        }\n    }\n}\n\n//==============================================================================\ngraph MonoReverb (int offset)\n{\n    input stream float audioIn, damping, feedback;\n    output stream float audioOut;\n\n    node comb1 = CombFilter (float, offset + 1116);\n    node comb2 = CombFilter (float, offset + 1188);\n    node comb3 = CombFilter (float, offset + 1277);\n    node comb4 = CombFilter (float, offset + 1356);\n    node comb5 = CombFilter (float, offset + 1422);\n    node comb6 = CombFilter (float, offset + 1491);\n    node comb7 = CombFilter (float, offset + 1557);\n    node comb8 = CombFilter (float, offset + 1617);\n\n    node allpass1 = AllpassFilter (float, offset + 225);\n    node allpass2 = AllpassFilter (float, offset + 341);\n    node allpass3 = AllpassFilter (float, offset + 441);\n    node allpass4 = AllpassFilter (float, offset + 556);\n\n    connection\n    {\n        audioIn -> comb1.in,\n                   comb2.in,\n                   comb3.in,\n                   comb4.in,\n                   comb5.in,\n                   comb6.in,\n                   comb7.in,\n                   comb8.in;\n\n        damping -> comb1.damping,\n                   comb2.damping,\n                   comb3.damping,\n                   comb4.damping,\n                   comb5.damping,\n                   comb6.damping,\n                   comb7.damping,\n                   comb8.damping;\n\n        feedback -> comb1.feedback,\n                    comb2.feedback,\n                    comb3.feedback,\n                    comb4.feedback,\n                    comb5.feedback,\n                    comb6.feedback,\n                    comb7.feedback,\n                    comb8.feedback;\n\n        comb1,\n        comb2,\n        comb3,\n        comb4,\n        comb5,\n        comb6,\n        comb7,\n        comb8  -> allpass1 -> allpass2 -> allpass3 -> allpass4  -> audioOut;\n    }\n}\n\n//==============================================================================\nprocessor AllpassFilter (using FrameType, int delayLength)\n{\n    input  stream FrameType in;\n    output stream FrameType out;\n\n    FrameType[delayLength] buffer;\n    wrap<delayLength> index;\n\n    void main()\n    {\n        loop\n        {\n            let newValue = in;\n            let delayedValue = buffer[index];\n            buffer[index] = newValue + (delayedValue * FrameType (0.5));\n            out <- delayedValue - newValue;\n            ++index;\n            advance();\n        }\n    }\n}\n\n//==============================================================================\nprocessor CombFilter (using FrameType, int delayLength)\n{\n    input  stream FrameType in;\n    output stream FrameType out;\n    input  stream float damping, feedback;\n\n    FrameType[delayLength] buffer;\n    wrap<delayLength> index;\n    FrameType last;\n    let gain = 0.015f;\n\n    void main()\n    {\n        loop\n        {\n            let delayedValue = buffer[index];\n            out <- delayedValue;\n            last = last * damping + delayedValue * (1.0f - damping);\n            buffer[index] = last * feedback + gain * in;\n            ++index;\n            advance();\n        }\n    }\n}\n",
			"id": "cJMx9fkaDyEpbHmJ",
			"mime": null
		}
	]
}