{
	"name": "ZitaReverb",
	"manifest": "ZitaReverb.cmajorpatch",
	"files": [
		{
			"name": "ZitaReverb.cmajorpatch",
			"type": "file",
			"binary": false,
			"content": "{\n    \"CmajorVersion\":    1,\n    \"ID\":               \"dev.cmajor.examples.zitaReverb\",\n    \"version\":          \"1.0\",\n    \"name\":             \"Zita Reverb\",\n    \"description\":      \"An implementation of the zita_rev1 reverb\",\n    \"category\":         \"generator\",\n    \"manufacturer\":     \"Cmajor Software Ltd\",\n    \"isInstrument\":     false,\n\n    \"source\":           \"ZitaReverb.cmajor\"\n}\n",
			"id": "SIPnLMRYM0D7HnJI",
			"mime": null
		},
		{
			"name": "ZitaReverb.cmajor",
			"type": "file",
			"binary": false,
			"content": "//\n//     ,ad888ba,                              88\n//    d8\"'    \"8b\n//   d8            88,dba,,adba,   ,aPP8A.A8  88     (C)2024 Cmajor Software Ltd\n//   Y8,           88    88    88  88     88  88\n//    Y8a.   .a8P  88    88    88  88,   ,88  88     https://cmajor.dev\n//     '\"Y888Y\"'   88    88    88  '\"8bbP\"Y8  88\n//                                           ,88\n//                                        888P\"\n//\n//  This code may be used under either a GPLv3 or commercial\n//  license: see LICENSE.md for more details.\n\n\n/// Although entirely rewritten when porting from C++ to Cmajor, the original C++ version\n/// of this algorithm was written by Fons Adriaensen <fons@linuxaudio.org>\n\ngraph ZitaReverb [[ main ]]\n{\n    input predelay.delayIn;\n    input core.crossoverIn;\n    input core.rtLowIn;\n    input core.rtMidIn;\n    input core.dampingIn;\n    input event float eq1FreqIn     [[ name: \"EQ1 Freq\",  min:  40,  max:  2500,  init:  400,  unit: \"hz\" ]];\n    input event float eq1GainIn     [[ name: \"EQ1 Gain\",  min: -15,  max:    15,  init:    0,  unit: \"db\" ]];\n    input event float eq2FreqIn     [[ name: \"EQ2 Freq\",  min: 160,  max: 10000,  init: 4000,  unit: \"hz\" ]];\n    input event float eq2GainIn     [[ name: \"EQ2 Gain\",  min: -15,  max:    15,  init:    0,  unit: \"db\" ]];\n    input dryWetMixer.mixIn;\n\n    input stream float<2> in;\n    output stream float<2> out;\n\n    node predelay = Delay(float<2>);\n    node core = ReverbCore;\n    node eq1 = ParametericEQ;\n    node eq2 = ParametericEQ;\n    node dryWetMixer = DryWetMixer;\n\n    connection\n    {\n        in               -> dryWetMixer.dryIn;\n        in               -> predelay.in;\n        eq1FreqIn        -> eq1.freqIn;\n        eq1GainIn        -> eq1.gainIn;\n        eq2FreqIn        -> eq2.freqIn;\n        eq2GainIn        -> eq2.gainIn;\n        predelay.out     -> core.in;\n        core.out         -> dryWetMixer.wetIn;\n        dryWetMixer.out  -> eq1.in;\n        eq1.out          -> eq2.in;\n        eq2.out          -> out;\n    }\n}\n\n//==============================================================================\nprocessor Delay (using DataType)\n{\n    input stream DataType in;\n    output stream DataType out;\n\n    input event float delayIn   [[ name: \"Delay\", min: 20, max: maxDelayLengthMs, init: 40, unit: \"ms\" ]];\n\n    let maxDelayLengthMs = 100;\n    let delaySize = int (processor.maxFrequency * maxDelayLengthMs / 1000.0);\n\n    wrap<delaySize> readPos, writePos;\n    DataType[delaySize] delay;\n\n    event delayIn (float delayMs)\n    {\n        let delayInSeconds = delayMs * 0.001f;\n        let delayInSamples = int (floor ((delayInSeconds - 0.020f) * float (processor.frequency) + 0.5f));\n        readPos = wrap<delaySize> (writePos - delayInSamples);\n    }\n\n    void main()\n    {\n        loop\n        {\n            delay[writePos++] = in;\n            out <- delay[readPos++];\n            advance();\n        }\n    }\n}\n\n//==============================================================================\nprocessor DryWetMixer\n{\n    output stream float<2> out;\n    input event float mixIn         [[ name: \"Mix\", min: 0, max: 100, init: 50, unit: \"%\" ]];\n    input stream float<2> dryIn, wetIn;\n\n    bool paramsChanged;\n    float mix;\n    float dryLevel, dryLevelDelta;\n    float wetLevel, wetLevelDelta;\n\n    event mixIn (float f)      { paramsChanged = true; mix = f * 0.01f;  }\n\n    void prepare (int blockSize)\n    {\n        dryLevelDelta = 0;\n        wetLevelDelta = 0;\n\n        if (paramsChanged)\n        {\n            let dryLevelTarget = (1 - mix) * (1 + mix);\n            let wetLevelTarget = 0.7f * mix * (2 - mix);\n            dryLevelDelta = (dryLevelTarget - dryLevel) / blockSize;\n            wetLevelDelta = (wetLevelTarget - wetLevel) / blockSize;\n\n            paramsChanged = false;\n        }\n    }\n\n    void main()\n    {\n        let blockSize = 32;\n\n        loop\n        {\n            prepare (blockSize);\n\n            loop (blockSize)\n            {\n                wetLevel += wetLevelDelta;\n                dryLevel += dryLevelDelta;\n                out <- wetLevel * wetIn + dryLevel * dryIn;\n                advance();\n            }\n        }\n    }\n}\n\n//==============================================================================\nprocessor ReverbCore\n{\n    input event float crossoverIn   [[ name: \"Crossover\", min: 50, max: 1000, init: 200, unit: \"hz\" ]];\n    input event float rtLowIn       [[ name: \"Low RT60\", min: 1, max: 8, init: 3, unit: \"secs\" ]];\n    input event float rtMidIn       [[ name: \"Mid RT60\", min: 1, max: 8, init: 2, unit: \"secs\" ]];\n    input event float dampingIn     [[ name: \"HF Damping\", min: 1.5, max: 24, init: 6, unit: \"khz\" ]];\n\n    input stream float<2> in;\n    output stream float<2> out;\n\n    event crossoverIn (float f)     { paramsChanged = true; crossover = f; }\n    event rtLowIn (float f)         { paramsChanged = true; rtLow = f; }\n    event rtMidIn (float f)         { paramsChanged = true; rtMid = f; }\n    event dampingIn (float f)       { paramsChanged = true; damping = f * 1000.0f; }\n\n    let delaySize = 16384;\n\n    struct DelayWithFeedback\n    {\n        void initialise (int size, float c)\n        {\n            this.writePos = wrap<delaySize> (size);\n            this.c = c;\n        }\n\n        float process (float x)\n        {\n            let z = this.line[this.readPos];\n            x -= this.c * z;\n            this.line[this.writePos] = x;\n            this.writePos++;\n            this.readPos++;\n            return z + this.c * x;\n        }\n\n        float c;\n        wrap<delaySize> readPos, writePos;\n        float[delaySize] line;\n    }\n\n    struct Filter\n    {\n        void setParams (float del, float tmf, float tlo, float wlo, float thi, float chi)\n        {\n            this.gmf = pow (0.001f, del / tmf);\n            this.glo = pow (0.001f, del / tlo) / this.gmf - 1.0f;\n            this.wlo = wlo;\n            let g = pow (0.001f, del / thi) / this.gmf;\n            let t = (1 - g * g) / (2 * g * g * chi);\n            this.whi = (sqrt (1 + 4 * t) - 1) / (2 * t);\n        }\n\n        float process (float x)\n        {\n            this.slo += this.wlo * (x - this.slo) + 1e-10f;\n            x += this.glo * this.slo;\n            this.shi += this.whi * (x - this.shi);\n            return this.gmf * this.shi;\n        }\n\n        float gmf, glo, wlo, whi, slo, shi;\n    }\n\n    struct Delay\n    {\n        void initialise (int size)\n        {\n            this.writePos = wrap<delaySize> (size);\n            this.readPos = 0;\n        }\n\n        float read()\n        {\n            return this.line[this.readPos];\n        }\n\n        void write (float f)\n        {\n            this.line[this.writePos] = f;\n            this.writePos++;\n            this.readPos++;\n        }\n\n        wrap<delaySize> readPos, writePos;\n        float[delaySize] line;\n    }\n\n    DelayWithFeedback[8] delayWithFeedback;\n    Filter[8] filter;\n    Delay[8] delay;\n\n    bool paramsChanged;\n    float crossover;\n    float rtLow;\n    float rtMid;\n    float damping;\n    float mix;\n    float wetLevel, wetLevelDelta;\n\n    const float[8] delayParams1 = ( 20346e-6f, 24421e-6f, 31604e-6f, 27333e-6f, 22904e-6f, 29291e-6f, 13458e-6f, 19123e-6f );\n    const float[8] delayParams2 = ( 153129e-6f, 210389e-6f, 127837e-6f, 256891e-6f, 174713e-6f, 192303e-6f, 125000e-6f, 219991e-6f );\n\n    void prepare (int numFrames)\n    {\n        wetLevelDelta = 0;\n\n        if (paramsChanged)\n        {\n            let wlo = 6.2832f * crossover / float (processor.frequency);\n\n            float chi = (damping > 0.49f * float (processor.frequency))\n                           ? 2.0f\n                           : 1.0f - cos (6.2832f * damping / float (processor.frequency));\n\n            for (wrap<8> i)\n                filter[i].setParams (delayParams2[i], rtMid, rtLow, wlo, 0.5f * rtMid, chi);\n\n            let wetLevelTarget = 1.0f / sqrt (rtMid);\n            wetLevelDelta = (wetLevelTarget - wetLevel) / numFrames;\n\n            paramsChanged = false;\n        }\n    }\n\n    void init()\n    {\n        for (wrap<8> i)\n        {\n            let k1 = int (floor (delayParams1[i] * float (processor.frequency) + 0.5f));\n            let k2 = int (floor (delayParams2[i] * float (processor.frequency) + 0.5f));\n            delayWithFeedback[i].initialise (k1, (i & 1) != 0 ? -0.6f : 0.6f);\n            delay[i].initialise (k2 - k1);\n        }\n    }\n\n    void shuffle (float& x, float& y)\n    {\n        let diff = x - y;\n        x += y;\n        y = diff;\n    }\n\n    float[8] shuffle (float[8] x)\n    {\n        shuffle (x[0], x[1]);\n        shuffle (x[2], x[3]);\n        shuffle (x[4], x[5]);\n        shuffle (x[6], x[7]);\n        shuffle (x[0], x[2]);\n        shuffle (x[1], x[3]);\n        shuffle (x[4], x[6]);\n        shuffle (x[5], x[7]);\n        shuffle (x[0], x[4]);\n        shuffle (x[1], x[5]);\n        shuffle (x[2], x[6]);\n        shuffle (x[3], x[7]);\n\n        return x;\n    }\n\n    void main()\n    {\n        let blockSize = 32;\n        let g = sqrt (0.125f);\n\n        loop\n        {\n            prepare (blockSize);\n\n            loop (blockSize)\n            {\n                let t0 = 0.3f * in[0];\n                let t1 = 0.3f * in[1];\n\n                let x = float[8]\n                (\n                    delayWithFeedback[0].process (delay[0].read() + t0),\n                    delayWithFeedback[1].process (delay[1].read() + t0),\n                    delayWithFeedback[2].process (delay[2].read() - t0),\n                    delayWithFeedback[3].process (delay[3].read() - t0),\n                    delayWithFeedback[4].process (delay[4].read() + t1),\n                    delayWithFeedback[5].process (delay[5].read() + t1),\n                    delayWithFeedback[6].process (delay[6].read() - t1),\n                    delayWithFeedback[7].process (delay[7].read() - t1)\n                );\n\n                let y = shuffle (x);\n\n                wetLevel += wetLevelDelta;\n                out <- wetLevel * float<2> ((y[1] + y[2]),\n                                            (y[1] - y[2]));\n\n                delay[0].write (filter[0].process (g * y[0]));\n                delay[1].write (filter[1].process (g * y[1]));\n                delay[2].write (filter[2].process (g * y[2]));\n                delay[3].write (filter[3].process (g * y[3]));\n                delay[4].write (filter[4].process (g * y[4]));\n                delay[5].write (filter[5].process (g * y[5]));\n                delay[6].write (filter[6].process (g * y[6]));\n                delay[7].write (filter[7].process (g * y[7]));\n\n                advance();\n            }\n        }\n    }\n}\n\n//==============================================================================\nprocessor ParametericEQ\n{\n    input event float freqIn    [[ name: \"EQ1 Freq\", min:  40, max: 2500, init: 400, unit: \"hz\" ]];\n    input event float gainIn    [[ name: \"EQ1 Gain\", min: -15, max: 15,   init:   0, unit: \"db\" ]];\n\n    input stream float<2> in;\n    output stream float<2> out;\n\n    event freqIn (float f)\n    {\n        f0 = f;\n        paramsChanged = true;\n    }\n\n    event gainIn (float g)\n    {\n        g0 = pow (10.0f, 0.05f * g);\n        paramsChanged = true;\n    }\n\n    enum State\n    {\n        bypass,\n        static,\n        smooth\n    }\n\n    void prepare (int numFrames)\n    {\n        if (paramsChanged)\n        {\n            bool isSmoothing = false;\n\n            if (g0 != g1)\n            {\n                isSmoothing = true;\n                if      (g0 > 2 * g1) g1 *= 2;\n                else if (g1 > 2 * g0) g1 /= 2;\n                else                  g1 = g0;\n            }\n\n            if (f0 != f1)\n            {\n                isSmoothing = true;\n                if      (f0 > 2 * f1) f1 *= 2;\n                else if (f1 > 2 * f0) f1 /= 2;\n                else                  f1 = f0;\n            }\n\n            if (isSmoothing)\n            {\n                state = State::smooth;\n                calcFilterSettings (numFrames, g1, f1);\n            }\n            else\n            {\n                paramsChanged = false;\n\n                if (abs (g1 - 1) < 0.001f)\n                {\n                    state = State::bypass;\n                    z1 = ();\n                    z2 = ();\n                }\n                else\n                {\n                    state = State::static;\n                }\n            }\n        }\n    }\n\n    void calcFilterSettings (int numFrames, float g, float f)\n    {\n        f = f * float (pi / processor.frequency);\n        let b = 2 * f / sqrt (g);\n        let lgg = 0.5f * (g - 1);\n        let lc1 = -cos (2 * f);\n        let lc2 = (1 - b) / (1 + b);\n\n        if (numFrames > 0)\n        {\n            dc1 = (lc1 - c1) / numFrames;\n            dc2 = (lc2 - c2) / numFrames;\n            dgg = (lgg - gg) / numFrames;\n        }\n        else\n        {\n            c1 = lc1;\n            c2 = lc2;\n            gg = lgg;\n        }\n    }\n\n    float<2> process (float<2> in)\n    {\n        var y = in - c2 * z2;\n        let result = in - gg * (z2 + c2 * y - in);\n        y -= c1 * z1;\n        z2 = z1 + c1 * y;\n        z1 = y + 1e-20f;\n\n        return result;\n    }\n\n    void init()\n    {\n        g0 = 1;\n        g1 = 1;\n        f0 = 1e3f;\n        f1 = 1e3f;\n\n        state = State::bypass;\n        calcFilterSettings (0, g1, f1);\n    }\n\n    void main()\n    {\n        const int blockSize = 32;\n\n        loop\n        {\n            prepare (blockSize);\n\n            if (state == State::bypass)\n            {\n                loop (blockSize)\n                {\n                    out <- in;\n                    advance();\n                }\n            }\n            else if (state == State::static)\n            {\n                loop (blockSize)\n                {\n                    out <- process (in);\n                    advance();\n                }\n            }\n            else\n            {\n                loop (blockSize)\n                {\n                    c1 += dc1;\n                    c2 += dc2;\n                    gg += dgg;\n                    out <- process (in);\n                    advance();\n                }\n            }\n        }\n    }\n\n    bool paramsChanged;\n    State state;\n    float g0, g1;\n    float f0, f1;\n    float c1, dc1;\n    float c2, dc2;\n    float gg, dgg;\n    float<2> z1, z2;\n}\n",
			"id": "dMlK6sCdCkk8W7Hg",
			"mime": null
		},
		{
			"name": "README.md",
			"type": "file",
			"binary": false,
			"content": "## Zita Reverb\n\nThis example patch is a Cmajor recreation of the Zita-rev1 reverb effect.\n\nDocumentation for the original Zita project is available on the [CCRMA website](https://ccrma.stanford.edu/~jos/Reverb/Zita_Rev1_Reverberator.html).\n",
			"id": "LpdvwQyNXdSK6pwl",
			"mime": "text/markdown"
		}
	]
}